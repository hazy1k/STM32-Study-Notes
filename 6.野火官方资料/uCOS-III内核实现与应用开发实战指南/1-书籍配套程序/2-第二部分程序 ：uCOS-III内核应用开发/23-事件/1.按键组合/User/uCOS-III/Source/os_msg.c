/*
************************************************************************************************************************
*                                                      uC/OS-III
*                                                 The Real-Time Kernel
*
*                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
*                           All rights reserved.  Protected by international copyright laws.
*
*                                              MESSAGE HANDLING SERVICES
*
* File    : OS_MSG.C
* By      : JJL
* Version : V3.03.01
*
* LICENSING TERMS:
* ---------------
*           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
*           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
*           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
*           application/product.   We provide ALL the source code for your convenience and to help you 
*           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
*           it commercially without paying a licensing fee.
*
*           Knowledge of the source code may NOT be used to develop a similar product.
*
*           Please help us continue to provide the embedded community with the finest software available.
*           Your honesty is greatly appreciated.
*
*           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
************************************************************************************************************************
*/

#define  MICRIUM_SOURCE
#include <os.h>

#ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
const  CPU_CHAR  *os_msg__c = "$Id: $";
#endif


#if OS_MSG_EN > 0u
/*$PAGE*/
/*
************************************************************************************************************************
*                                            INITIALIZE THE POOL OF 'OS_MSG'
*
* Description: This function is called by OSInit() to initialize the free list of OS_MSGs.
*
* Argument(s): p_err     is a pointer to a variable that will contain an error code returned by this function.
*
*                            OS_ERR_MSG_POOL_NULL_PTR
*                            OS_ERR_MSG_POOL_EMPTY
*                            OS_ERR_NONE
*
* Returns    : none
*
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_MsgPoolInit (OS_ERR  *p_err)   //返回错误类型
{
    OS_MSG      *p_msg1;
    OS_MSG      *p_msg2;
    OS_MSG_QTY   i;
    OS_MSG_QTY   loops;



#ifdef OS_SAFETY_CRITICAL               //如果使能（默认禁用）了安全检测
    if (p_err == (OS_ERR *)0) {         //如果错误类型实参为空
        OS_SAFETY_CRITICAL_EXCEPTION(); //执行安全检测异常函数
        return;                         //返回，停止执行
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u                    //如果使能了参数检测
    if (OSCfg_MsgPoolBasePtr == (OS_MSG *)0) {//如果消息池不存在
       *p_err = OS_ERR_MSG_POOL_NULL_PTR;     //错误类型为“消息池指针为空”
        return;                               //返回，停止执行
    }
    if (OSCfg_MsgPoolSize == (OS_MSG_QTY)0) { //如果消息池不能存放消息
       *p_err = OS_ERR_MSG_POOL_EMPTY;        //错误类型为“消息池为空”
        return;                               //返回，停止执行
    }
#endif
    /* 将消息池里的消息逐条串成单向链表，方便管理 */
    p_msg1 = OSCfg_MsgPoolBasePtr;           
    p_msg2 = OSCfg_MsgPoolBasePtr;
    p_msg2++;
    loops  = OSCfg_MsgPoolSize - 1u;
    for (i = 0u; i < loops; i++) {            //初始化每一条消息 
        p_msg1->NextPtr = p_msg2;
        p_msg1->MsgPtr  = (void      *)0;
        p_msg1->MsgSize = (OS_MSG_SIZE)0u;
        p_msg1->MsgTS   = (CPU_TS     )0u;
        p_msg1++;
        p_msg2++;
    }
    p_msg1->NextPtr = (OS_MSG    *)0;         //最后一条消息
    p_msg1->MsgPtr  = (void      *)0;
    p_msg1->MsgSize = (OS_MSG_SIZE)0u;
    p_msg1->MsgTS   = (CPU_TS     )0u;
    /* 初始化消息池数据 */
    OSMsgPool.NextPtr    =  OSCfg_MsgPoolBasePtr;
    OSMsgPool.NbrFree    =  OSCfg_MsgPoolSize;
    OSMsgPool.NbrUsed    = (OS_MSG_QTY)0;
    OSMsgPool.NbrUsedMax = (OS_MSG_QTY)0;
   *p_err                =  OS_ERR_NONE;      //错误类型为“无错误”
}

/*$PAGE*/
/*
************************************************************************************************************************
*                                        RELEASE ALL MESSAGE IN MESSAGE QUEUE
*
* Description: This function returns all the messages in a message queue to the free list.
*
* Arguments  : p_msg_q       is a pointer to the OS_MSG_Q structure containing messages to free.
*              -------
*
* Returns    : the number of OS_MSGs returned to the free list
*
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

OS_MSG_QTY  OS_MsgQFreeAll (OS_MSG_Q  *p_msg_q)
{
    OS_MSG      *p_msg;
    OS_MSG_QTY   qty;



    qty = p_msg_q->NbrEntries;                              /* Get the number of OS_MSGs being freed                  */
    if (p_msg_q->NbrEntries > (OS_MSG_QTY)0) {
        p_msg                   = p_msg_q->InPtr;           /* Point to end of message chain                          */
        p_msg->NextPtr          = OSMsgPool.NextPtr;
        OSMsgPool.NextPtr       = p_msg_q->OutPtr;          /* Point to beginning of message chain                    */
        OSMsgPool.NbrUsed      -= p_msg_q->NbrEntries;      /* Update statistics for free list of messages            */
        OSMsgPool.NbrFree      += p_msg_q->NbrEntries;
        p_msg_q->NbrEntries     = (OS_MSG_QTY)0;            /* Flush the message queue                                */
        p_msg_q->NbrEntriesMax  = (OS_MSG_QTY)0;
        p_msg_q->InPtr          = (OS_MSG   *)0;
        p_msg_q->OutPtr         = (OS_MSG   *)0;
    }
    return (qty);
}

/*$PAGE*/
/*
************************************************************************************************************************
*                                               INITIALIZE A MESSAGE QUEUE
*
* Description: This function is called to initialize a message queue
*
* Arguments  : p_msg_q      is a pointer to the message queue to initialize
*              -------
*
*              max          is the maximum number of entries that a message queue can have.
*
* Returns    : none
*
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_MsgQInit (OS_MSG_Q    *p_msg_q, //消息队列指针
                   OS_MSG_QTY   size)    //消息队列空间
{
    p_msg_q->NbrEntriesSize = (OS_MSG_QTY)size; //消息队列可存放消息数目
    p_msg_q->NbrEntries     = (OS_MSG_QTY)0;    //消息队列目前可用消息数
    p_msg_q->NbrEntriesMax  = (OS_MSG_QTY)0;    //可用消息数的最大历史记录
    p_msg_q->InPtr          = (OS_MSG   *)0;    //队列的入队指针
    p_msg_q->OutPtr         = (OS_MSG   *)0;    //队列的出队指针
}

/*$PAGE*/
/*
************************************************************************************************************************
*                                           RETRIEVE MESSAGE FROM MESSAGE QUEUE
*
* Description: This function retrieves a message from a message queue
*
* Arguments  : p_msg_q     is a pointer to the message queue where we want to extract the message from
*              -------
*
*              p_msg_size  is a pointer to where the size (in bytes) of the message will be placed
*
*              p_ts        is a pointer to where the time stamp will be placed
*
*              p_err       is a pointer to an error code that will be returned from this call.
*
*                              OS_ERR_Q_EMPTY
*                              OS_ERR_NONE
*
* Returns    : The message (a pointer)
*
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  *OS_MsgQGet (OS_MSG_Q     *p_msg_q,     //消息队列
                   OS_MSG_SIZE  *p_msg_size,  //返回消息大小
                   CPU_TS       *p_ts,        //返回某些操作的时间戳
                   OS_ERR       *p_err)       //返回错误类型
{
    OS_MSG  *p_msg;
    void    *p_void;



#ifdef OS_SAFETY_CRITICAL               //如果使能（默认禁用）了安全检测
    if (p_err == (OS_ERR *)0) {         //如果错误类型实参为空
        OS_SAFETY_CRITICAL_EXCEPTION(); //执行安全检测异常函数
        return ((void *)0);             //返回空消息，停止执行
    }
#endif

    if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {  //如果消息队列没有消息
       *p_msg_size = (OS_MSG_SIZE)0;             //返回消息长度为0
        if (p_ts != (CPU_TS *)0) {               //如果 p_ts 非空
           *p_ts  = (CPU_TS  )0;                 //清零 p_ts
        }
       *p_err = OS_ERR_Q_EMPTY;                  //错误类型为“队列没消息”
        return ((void *)0);                      //返回空消息，停止执行
    }
    /* 如果消息队列有消息 */
    p_msg           = p_msg_q->OutPtr;          //从队列的出口端提取消息           
    p_void          = p_msg->MsgPtr;            //提取消息内容
   *p_msg_size      = p_msg->MsgSize;           //提取消息长度
    if (p_ts != (CPU_TS *)0) {                  //如果 p_ts 非空
       *p_ts  = p_msg->MsgTS;                   //获取消息被发布时的时间戳
    }

    p_msg_q->OutPtr = p_msg->NextPtr;           //修改队列的出队指针

    if (p_msg_q->OutPtr == (OS_MSG *)0) {       //如果队列没有消息了
        p_msg_q->InPtr      = (OS_MSG   *)0;    //清零出队指针
        p_msg_q->NbrEntries = (OS_MSG_QTY)0;    //清零消息数
    } else {                                    //如果队列还有消息
        p_msg_q->NbrEntries--;                  //队列的消息数减1
    }
    /* 从消息队列提取完消息信息后，将消息释放回消息池供继续使用 */
    p_msg->NextPtr    = OSMsgPool.NextPtr;      //消息插回消息池
    OSMsgPool.NextPtr = p_msg;
    OSMsgPool.NbrFree++;                        //消息池的可用消息数加1
    OSMsgPool.NbrUsed--;                        //消息池的已用消息数减1

   *p_err             = OS_ERR_NONE;            //错误类型为“无错误”
    return (p_void);                            //返回罅隙内容
}

/*$PAGE*/
/*
************************************************************************************************************************
*                                           DEPOSIT MESSAGE IN MESSAGE QUEUE
*
* Description: This function places a message in a message queue
*
* Arguments  : p_msg_q     is a pointer to the OS_TCB of the task to post the message to
*              -------
*
*              p_void      is a pointer to the message to send.
*
*              msg_size    is the size of the message (in bytes)
*
*              opt         specifies whether the message will be posted in FIFO or LIFO order
*
*                              OS_OPT_POST_FIFO
*                              OS_OPT_POST_LIFO
*
*              ts          is a timestamp as to when the message was posted
*
*              p_err       is a pointer to a variable that will contain an error code returned by this function.
*
*                              OS_ERR_Q_MAX           if the queue is full
*                              OS_ERR_MSG_POOL_EMPTY  if we no longer have any OS_MSG to use
*                              OS_ERR_NONE            the message was deposited in the queue
*
* Returns    : none
*
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_MsgQPut (OS_MSG_Q     *p_msg_q,   //消息队列指针
                  void         *p_void,    //消息指针
                  OS_MSG_SIZE   msg_size,  //消息大小（单位：字节）
                  OS_OPT        opt,       //选项
                  CPU_TS        ts,        //消息被发布时的时间戳
                  OS_ERR       *p_err)     //返回错误类型
{
    OS_MSG  *p_msg;
    OS_MSG  *p_msg_in;



#ifdef OS_SAFETY_CRITICAL                //如果使能了安全检测
    if (p_err == (OS_ERR *)0) {          //如果错误类型实参为空
        OS_SAFETY_CRITICAL_EXCEPTION();  //执行安全检测异常函数
        return;                          //返回，停止执行
    }
#endif

    if (p_msg_q->NbrEntries >= p_msg_q->NbrEntriesSize) { //如果消息队列已没有可用空间
       *p_err = OS_ERR_Q_MAX;                             //错误类型为“队列已满”
        return;                                           //返回，停止执行
    }

    if (OSMsgPool.NbrFree == (OS_MSG_QTY)0) {  //如果消息池没有可用消息
       *p_err = OS_ERR_MSG_POOL_EMPTY;         //错误类型为“消息池没有消息”  
        return;                                //返回，停止执行
    }
    /* 从消息池获取一个消息（暂存于 p_msg ）*/
    p_msg             = OSMsgPool.NextPtr;          //将消息控制块从消息池移除               
    OSMsgPool.NextPtr = p_msg->NextPtr;             //指向下一个消息（取走首个消息）
    OSMsgPool.NbrFree--;                            //消息池可用消息数减1
    OSMsgPool.NbrUsed++;                            //消息池被用消息数加1
    if (OSMsgPool.NbrUsedMax < OSMsgPool.NbrUsed) { //更新消息被用最大数目的历史记录
        OSMsgPool.NbrUsedMax = OSMsgPool.NbrUsed;
    }
    /* 将获取的消息插入到消息队列 */
    if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {             //如果消息队列目前没有消息
        p_msg_q->InPtr         = p_msg;                     //将其入队指针指向该消息
        p_msg_q->OutPtr        = p_msg;                     //出队指针也指向该消息
        p_msg_q->NbrEntries    = (OS_MSG_QTY)1;             //队列的消息数为1
        p_msg->NextPtr         = (OS_MSG *)0;               //该消息的下一个消息为空
    } else {                                                //如果消息队列目前已有消息
        if ((opt & OS_OPT_POST_LIFO) == OS_OPT_POST_FIFO) { //如果用FIFO方式插入队列，
            p_msg_in           = p_msg_q->InPtr;            //将消息插入到入队端，入队
            p_msg_in->NextPtr  = p_msg;                     //指针指向该消息。
            p_msg_q->InPtr     = p_msg;
            p_msg->NextPtr     = (OS_MSG *)0;
        } else {                                            //如果用LIFO方式插入队列，
            p_msg->NextPtr     = p_msg_q->OutPtr;           //将消息插入到出队端，出队
            p_msg_q->OutPtr    = p_msg;                     //指针指向该消息。
        }
        p_msg_q->NbrEntries++;                              //消息队列的消息数目加1
    }
    if (p_msg_q->NbrEntriesMax < p_msg_q->NbrEntries) {     //更新改消息队列的最大消息
        p_msg_q->NbrEntriesMax = p_msg_q->NbrEntries;       //数目的历史记录。
    }
    p_msg->MsgPtr  = p_void;                                //给该消息填写消息内容
    p_msg->MsgSize = msg_size;                              //给该消息填写消息大小
    p_msg->MsgTS   = ts;                                    //填写发布该消息时的时间戳
   *p_err          = OS_ERR_NONE;                           //错误类型为“无错误”
}
#endif
