/**************************************************************************************
* 因为emWin显示只支持UTF-8编码格式的中文，如果希望直接显示在Keil直接输入的中文，      *
*            比如使用：GUI_DispStringHCenterAt("流水灯",110,120);                     *
* 该文件必须以UTF-8编码格式，不然中文无法正常显示。                                   *
*                                                                                     *
* 如果只是个别例程出现中文显示乱码（如果所有例程都无法显示中文可能是字库问题），      *
* 把对应的例程文件(比如LEDapp.c)用电脑的记事本软件打开，然后选择另存为，在弹出对      *
* 话框中“保存(S)"按钮的左边有个"编码(E)"选项，选择"UTF-8",然后同样保存为同名称的      *
* C语言文件(覆盖原来文件)，再编译。                                                   *
*                                                                                     *
* 如果编译工程时出现下面类似错误也是该文件编码格式问题,必须把文件保存为UTF-8格式      *
* 再编译                                                                              *
* ..\..\User\app\LEDapp.c(275): error:  #8: missing closing quote                     *
*        GUI_DispStringHCenterAt("娴?姘?鐏?",110,120);                                *
* ..\..\User\app\LEDapp.c(276): error:  #165: too few arguments in function call      *
*        GUI_DispStringHCenterAt("瑙?鎽?鍋?宸?澶?鎵?闇€瑕?瑙?鎽?鏍?鍑?",110,215);     *
* ..\..\User\app\LEDapp.c(276): error:  #18: expected a ")"                           *
*        GUI_DispStringHCenterAt("瑙?鎽?鍋?宸?澶?鎵?闇€瑕?瑙?鎽?鏍?鍑?",110,215);     *
*                                                                                     *
* 修改文件后编译就出错这是Keil5软件问题(Keil4没这问题)，推荐使用其他程序编辑工具，    *
* 只用Keil5完成编译和下载工作。                                                       *
***************************************************************************************
*                      实验平台: 野火STM32 ISO 开发板                                 *
*                      论    坛: http://www.chuxue123.com                             *
*                      淘    宝: http://firestm32.taobao.com                          *
*                      邮    箱: wildfireteam@163.com                                 *
***************************************************************************************
*/
/**************************************************************************************
*                                                                                     *
*                SEGGER Microcontroller GmbH & Co. KG                                 *
*        Solutions for real time microcontroller applications                         *
*                                                                                     *
***************************************************************************************
*                                                                                     *
* C-file generated by:                                                                *
*                                                                                     *
*        GUI_Builder for emWin version 5.22                                           *
*        Compiled Jul  4 2013, 15:16:01                                               *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG                                *
*                                                                                     *
***************************************************************************************
*                                                                                     *
*        Internet: www.segger.com  Support: support@segger.com                        *
*                                                                                     *
***************************************************************************************
*/
// USER START (Optionally insert additional includes)
#include "includes.h"
#include  "app.h"
// USER END
/**************************************************************************************
*
*       Defines
*
***************************************************************************************
*/
// USER START (Optionally insert additional defines)

#define BUFSIZE				512
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
// USER START (Optionally insert additional static data)
extern GUI_CONST_STORAGE GUI_BITMAP bmwave;
extern GUI_CONST_STORAGE GUI_BITMAP bmmic;
extern GUI_CONST_STORAGE GUI_BITMAP bmanote;


static uint8_t Replay=0,RecordFlag=0;
static TCHAR recfilename[25]={"1:/recorder/rec001.wav"};
static __WaveHeader rechead;

static char tempstr[12]={"rec001.wav"};
static _recorder_obj recset;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreateRecorder[] = {
  { FRAMEWIN_CreateIndirect, "Recorder",   0,                0, 0, 240, 320,   0, 0x64, 0 },
	{ DROPDOWN_CreateIndirect, "rate",       GUI_ID_DROPDOWN0, 75, 30, 60, 36, 0, 0x0, 0 },	
  { DROPDOWN_CreateIndirect, "Agc",        GUI_ID_DROPDOWN1, 160, 30, 60, 86, 0, 0x0, 0 },
	{ RADIO_CreateIndirect,    "input",      GUI_ID_RADIO0,    5, 30, 60, 44, 0, 0x1402, 0 },
	{ RADIO_CreateIndirect,    "Channel",    GUI_ID_RADIO1,    5, 90, 60, 66, 0, 0x1402, 0 },
	
  //{ SLIDER_CreateIndirect,   "Volume",     GUI_ID_SLIDER0,   130, 160, 90, 20, 0, 0x0,  0 },	
  { BUTTON_CreateIndirect,   "Record",     GUI_ID_BUTTON0,   40, 190, 58, 58,  0, 0x0,  0 },
  { BUTTON_CreateIndirect,   "Replay",     GUI_ID_BUTTON1,   135, 190, 58, 58, 0, 0x0,  0 },
	{ TEXT_CreateIndirect,     "Name",       GUI_ID_TEXT0,     100, 90, 100, 22, 0, 0x64, 0 },
	{ TEXT_CreateIndirect,     "Time",       GUI_ID_TEXT1,     115, 130, 60, 20, 0, 0x64, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
// USER START (Optionally insert additional static code)
void recorder(const TCHAR *recfile,WM_HWIN hWin)
{
	uint32_t sectorsize=0;
	uint16_t recsec=0;					//录音时间
	uint16_t idx=0;
	uint16_t regval=0;
	
	com_data2null(comdata,COMDATA_SIZE);
	
	recoder_enter_rec_mode(&recset);
	
	while(VS_RD_Reg(SPI_HDAT1)>>8);			//等到buf 较为空闲再开始

	rechead.riff.ChunkID=0X46464952;	//"RIFF"
	rechead.riff.ChunkSize=0;			//还未确定,最后需要计算
	rechead.riff.Format=0X45564157; 	//"WAVE"
	rechead.fmt.ChunkID=0X20746D66; 	//"fmt "
	rechead.fmt.ChunkSize=16; 			//大小为16个字节
	rechead.fmt.AudioFormat=0X01; 		//0X01,表示PCM;0X01,表示IMA ADPCM
	rechead.fmt.NumOfChannels=1;		//单声道	
 	rechead.fmt.SampleRate=recset.samplerate*8000;		//采样速率
 	rechead.fmt.ByteRate=rechead.fmt.SampleRate*2;//16位,即2个字节
 	rechead.fmt.BlockAlign=2;			//块大小,2个字节为一个块
 	rechead.fmt.BitsPerSample=16;		//16位PCM
  rechead.data.ChunkID=0X61746164;	//"data"
 	rechead.data.ChunkSize=0;			//数据大小,还需要计算  

	result=f_open(&file,recfile, FA_CREATE_ALWAYS | FA_WRITE); 
	if(result)
		return;
	else
		result=f_write(&file,&rechead,sizeof(__WaveHeader),&bw);//写入头数据
	//printf("write result:%d,num:%d\n",result,bw);
	while(1)
	{
		if((RecordFlag==2)|| (Flag_ICON001==0))
		{
			rechead.riff.ChunkSize=sectorsize*BUFSIZE+36;	//整个文件的大小-8;
			rechead.data.ChunkSize=sectorsize*BUFSIZE;		//数据大小
			f_lseek(&file,0);							//偏移到文件头.
			result=f_write(&file,&rechead,sizeof(__WaveHeader),&bw);//写入头数据
			//printf("%s->write sector:%d,result:%d,num:%d\n",recfile,sectorsize,result,bw);
			f_close(&file);
			VS_HD_Reset();		   	//硬复位
			VS_Soft_Reset();  		//软复位 
			sectorsize=0;
			RecordFlag=0;
			return;//break;
		}
		regval=VS_RD_Reg(SPI_HDAT1);	
		if((regval>=256)&&(regval<896))
		{
			idx=0;				   	 
			while(idx<BUFSIZE) 	//一次读取BUFSIZE字节
			{	 
				regval=VS_RD_Reg(SPI_HDAT0);
				comdata[idx]=regval&0XFF;
				comdata[idx+1]=regval>>8;
				idx+=2;
			}	 
			f_lseek(&file,44+sectorsize*BUFSIZE);
			result=f_write(&file,comdata,BUFSIZE,&bw);//写入文件
			if(result)
			{
				printf("err:%d bw:%d\n",result,bw);
				break;//写入出错.	  
			}
			sectorsize++;//扇区数增加1
		}
		if(recsec!=(sectorsize*4/125/recset.samplerate))//录音时间显示
		{
			recsec=sectorsize*4/125/recset.samplerate;
			sprintf(tempstr,"%02d:%02d",recsec/60,recsec%60);
			tempstr[5]='\0';
			TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT1),tempstr);
		}
		if(tpad_flag)WM_DeleteWindow(hWin);
		WM_Exec();//GUI_Delay(1);//
	}
	//f_close(&sdfile);
}

void record_play(uint8_t *recfile,WM_HWIN hWin)
{
	uint16_t i=0,time=0,oldtime=0;
	uint16_t f_kbps=0xffff;
	OS_ERR      err;
	//if(strstr((const char *)recfile,"recorder")==0)return 0xff;
	com_data2null(comdata,COMDATA_SIZE);
	
	VS_Restart_Play();  					//重启播放 
	VS_Set_All();        	//设置音量等信息
	VS_Reset_DecodeTime();	//复位解码时间 	 
	result=f_open(&file,(const TCHAR*)recfile,FA_READ);
	if(result==0)
	{ 
			VS_SPI_SpeedHigh();						   
			while(Replay)
			{
				i=0;	
				result=f_read(&file,comdata,COMDATA_SIZE,(UINT*)&bw);	
				if(f_kbps==0xffff)
				{
						f_kbps=(uint16_t)((comdata[25]*256+comdata[24])*32/1000);
				}
				OSSchedLock(&err);
				while(i<bw)
			  {  	
					if(VS_Send_MusicData(comdata+i)==0)
					{
						i+=32;
					}
				}
				OSSchedUnlock(&err);
				if((bw!=COMDATA_SIZE)||(result!=0))
				{		
					break;
				}
				if(tpad_flag)WM_DeleteWindow(hWin);
				GUI_Delay(1);				
				if(Flag_ICON001==0)
				{					
					f_close(&file);
					return;
				}				
				oldtime=f_tell(&file)/f_kbps/125;
				if((time+1)<=oldtime)
				{
					time=oldtime;
					sprintf(tempstr,"%02d:%02d",time/60,time%60);
					tempstr[5]='\0';
					TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT1),tempstr);
				}
			}
		}
		BUTTON_SetBitmapEx(WM_GetDialogItem(hWin, GUI_ID_BUTTON1),BUTTON_BI_UNPRESSED,&bmanote,5,5);
		TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT1),"00:00");
		WM_EnableWindow(WM_GetDialogItem(hWin, GUI_ID_BUTTON0));
		Replay=0;
		f_close(&file);
}
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialogRecorder(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
	uint8_t sel=0;
  // USER END

  switch (pMsg->MsgId) {
		case WM_DELETE:
		OS_INFO("Recorderapp delete\n");
		Replay=0;
		RecordFlag=0;
		UserApp_Flag = 0;
	  Flag_ICON001 = 0;
	break;
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Recorder'
    //
   	hItem = pMsg->hWin;
		FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
		FRAMEWIN_SetFont(hItem, GUI_FONT_16B_ASCII);
		FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
		FRAMEWIN_AddCloseButton(hItem,FRAMEWIN_BUTTON_RIGHT,0);
		FRAMEWIN_SetTitleHeight(hItem, 20);
		//
    // Initialization of 'rate'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_DROPDOWN0);
    DROPDOWN_SetFont(hItem, GUI_FONT_16B_ASCII);	
    DROPDOWN_AddString(hItem, "8K");
    DROPDOWN_AddString(hItem, "16K");
		DROPDOWN_SetSel(hItem,0);		
		WM_BringToTop(hItem);
		//
    // Initialization of 'Agc'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_DROPDOWN1);
    DROPDOWN_SetFont(hItem, GUI_FONT_16B_ASCII);	
    DROPDOWN_AddString(hItem, "0.5x");
    DROPDOWN_AddString(hItem, "1x");
    DROPDOWN_AddString(hItem, "2x");
    DROPDOWN_AddString(hItem, "4x");
    DROPDOWN_AddString(hItem, "16x");
		DROPDOWN_SetSel(hItem,1);		
		WM_BringToTop(hItem);
		//
    // Initialization of 'input'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO0);
    RADIO_SetFont(hItem, GUI_FONT_16B_ASCII);
    RADIO_SetText(hItem, "MICP", 0);
    RADIO_SetText(hItem, "LINE1", 1);
    //
    // Initialization of 'Channel'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO1);
    RADIO_SetFont(hItem, GUI_FONT_16B_ASCII);
    RADIO_SetText(hItem, "Left", 0);
    RADIO_SetText(hItem, "Right", 1);
		RADIO_SetValue(hItem,0);
		WM_DisableWindow(hItem);
    //
    // Initialization of 'Record'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0);
		BUTTON_SetText(hItem,"");
		BUTTON_SetBitmapEx(hItem,BUTTON_BI_UNPRESSED,&bmmic,5,5);
    //
    // Initialization of 'Replay'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1);
		BUTTON_SetText(hItem,"");
		BUTTON_SetBitmapEx(hItem,BUTTON_BI_UNPRESSED,&bmanote,5,5);
		//
		// Initialization of 'Name'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
    TEXT_SetFont(hItem, GUI_FONT_20B_ASCII);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "name");
		//
		// Initialization of 'Time'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT1);
    TEXT_SetFont(hItem, GUI_FONT_16B_ASCII);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "00:00");
//		//
//		// Initialization of 'Volume'
//		//
//		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_SLIDER0);
//		SLIDER_SetRange(hItem,140,254);
//		SLIDER_SetValue(hItem,vsset.mvol);
//		SLIDER_SetWidth(hItem,7);
//		SLIDER_SetNumTicks(hItem,15);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
		case GUI_ID_DROPDOWN0: // Notifications sent by 'rate'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)				
        // USER END
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
				sel=DROPDOWN_GetSel(WM_GetDialogItem(pMsg->hWin, GUI_ID_DROPDOWN0));
				recset.samplerate = sel+1;
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
		case GUI_ID_DROPDOWN1: // Notifications sent by 'Age'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)				
        // USER END
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
				sel=DROPDOWN_GetSel(WM_GetDialogItem(pMsg->hWin, GUI_ID_DROPDOWN1));
				switch(sel)//recset.agc是整数为实现0.5x效果，这里先把recset.agc增加一倍
				{
					case 0:
						recset.agc = 1;	//实际增益为0.5
						break;
					case 1:
						recset.agc = 2;	//实际增益为1
						break;
					case 2:
						recset.agc = 4;	//实际增益为2
						break;
					case 3:
						recset.agc = 8;	//实际增益为4
						break;
					case 4:
						recset.agc = 32; //实际增益为16
						break;
				}
							
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
		case GUI_ID_RADIO0: // Notifications sent by 'input'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
				sel=RADIO_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO0));
				recset.input=sel;
				if(sel==0)//MICP
				{
					RADIO_SetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO1),0);
					recset.channel=0;
					WM_DisableWindow((WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO1)));
				}
				else//LINE1
				{
					WM_EnableWindow((WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO1)));
				}
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_RADIO1: // Notifications sent by 'Channel'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
				sel=RADIO_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_RADIO1));
				recset.channel=sel;
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
//		case GUI_ID_SLIDER0: // Notifications sent by 'Volume'
//      switch(NCode) {
//      case WM_NOTIFICATION_CLICKED:
//        // USER START (Optionally insert code for reacting on notification message)
//        // USER END
//        break;
//      case WM_NOTIFICATION_RELEASED:
//        // USER START (Optionally insert code for reacting on notification message)
//				hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_SLIDER0);
//				vsset.mvol=SLIDER_GetValue(hItem);
//				VS_Set_Vol(vsset.mvol);
//        // USER END
//        break;
//      // USER START (Optionally insert additional code for further notification handling)
//      // USER END
//      }
//      break;			
    case GUI_ID_BUTTON0: // Notifications sent by 'Record'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
				if(RecordFlag)
				{
					RecordFlag=2;
					BUTTON_SetBitmapEx(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0),BUTTON_BI_UNPRESSED,&bmmic,5,5);
					TEXT_SetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT1),"00:00");
					WM_EnableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1));
				}
				else
				{
					RecordFlag=1;
					BUTTON_SetBitmapEx(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0),BUTTON_BI_UNPRESSED,&bmwave,5,5);
					WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1));
				}
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_BUTTON1: // Notifications sent by 'Replay'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
				if((RecordFlag==0)&&(Replay==0))
				{
					BUTTON_SetBitmapEx(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1),BUTTON_BI_UNPRESSED,&bmwave,5,5);
					Replay=1;
					WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0));
				}else	if(Replay)
				{
					Replay=0;
					WM_EnableWindow(WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0));
				}
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
	case WM_PAINT:
		GUI_SetBkColor(APPBKCOLOR);
		GUI_SetColor(APPTEXTCOLOR);
		GUI_Clear();
		GUI_DispStringHCenterAt("输入    采样率     增益",110,8);
		GUI_DispStringAt("声道",12,72);
		break;				
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateRecorder
*/
void FUN_ICON001Clicked(void)
{
	uint8_t i=1;
	WM_HWIN hWin;
	tempstr[10]='\0';
	recfilename[22]='\0';
	
	OS_INFO("Recorderapp create\n");
	
	vsset.mvol=240;			//音量大小
	vsset.bflimit=6;		//低音限制
	vsset.bass=15;			//低音效果
	vsset.tflimit =10;	//高音限制
	vsset.treble =15;		//高音效果
	vsset.effect =0;		//无耳机效果
	vsset.speed =1;			//正常速度
	
	recset.input =0;			//MIC
	recset.samplerate =1;	//8K
	recset.channel =0;		//左声道
	recset.agc = 2;				//实际增益为1
	
	VS_Init();
	bsp_DelayUS(1000);
//	printf("vs1053:%4X\n",VS_Ram_Test());
//	GUI_Delay(100);
//	VS_Sine_Test();
	VS_HD_Reset();
	VS_Soft_Reset();
	
	hWin=GUI_CreateDialogBox(_aDialogCreateRecorder, GUI_COUNTOF(_aDialogCreateRecorder), _cbDialogRecorder, WM_HBKWIN, 0, 0);	

	com_createdir("1:/recorder");
	while(Flag_ICON001)
	{
		if(RecordFlag==1)
		{
			i=1;
			while(i<0xff)
			{
				sprintf((char *)recfilename,"1:/recorder/rec%03d.wav",i);
				result=f_open(&file,(const TCHAR*)recfilename,FA_READ);
				//printf("f_open_res:%d\n",result);
				if(result==FR_NO_FILE)break;	
				else
						f_close(&file);
				i++;
			}
			//printf("record:filename:%s\n",recfilename);
			if(i==0xff)
			{
				RecordFlag=0;
				continue;
			}
			sprintf((char *)tempstr,"rec%03d.wav",i);
			tempstr[10]='\0';
			TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT0),tempstr);
			recorder((const TCHAR*)recfilename,hWin);	
		}
		if((RecordFlag==0)&&(Replay==1))
		{
			sprintf((char *)tempstr,"rec%03d.wav",i);
			tempstr[10]='\0';
			TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT0),tempstr);			
			//printf("play:filename:%s\n",recfilename);
			record_play((uint8_t *)recfilename,hWin);
		}
		if(tpad_flag)WM_DeleteWindow(hWin);
		GUI_Delay(10);
	}
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/

