/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.26                          *
*        Compiled Aug  8 2014, 14:49:54                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "includes.h"
// USER END

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
GUI_XBF_DATA XBF_Data;
GUI_FONT     XBF_Font;

extern FRESULT result;
extern FIL file;
extern UINT bw;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Touch", 0, 0, 0, 240, 320, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", GUI_ID_BUTTON0, 20, 200, 200, 40, 0, 0x0, 0 },
  { SCROLLBAR_CreateIndirect, "Scrollbar", GUI_ID_SCROLLBAR0, 20, 70, 200, 20, 0, 0x0, 0 },
  { SLIDER_CreateIndirect, "Slider", GUI_ID_SLIDER0, 20, 140, 200, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, 	"cpu", 	GUI_ID_TEXT0, 	100, 40, 50, 20, 0, 0x64, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
#if 0
//直接读取放在外部Flash文件系统内的XBF字库文件，实测显示速度慢
/*
*********************************************************************************************************
*
*       _cbGetData
*
* Function description
*   Callback function for getting font data
*
* Parameters:
*   Off      - Position of XBF file to be read
*   NumBytes - Number of requested bytes
*   pVoid    - Application defined pointer
*   pBuffer  - Pointer to buffer to be filled by the function
*
* Return value:
*   0 on success, 1 on error
*********************************************************************************************************
*/
static int _cbGetData(U32 Offset, U16 NumBytes, void * pVoid, void * pBuffer)
{
	FIL *FontFile;

	/* The pVoid pointer may be used to get a file handle */
	FontFile = (FIL *)pVoid;

	/*
	* Set file pointer to the required position
	*/
	result =f_lseek(FontFile, Offset);
	if (result != FR_OK) 
	{
		return 1; /* Error */
	}

	/*
	* Read data into buffer
	*/
	result = f_read(FontFile, pBuffer, NumBytes, &bw);
	if (result != FR_OK) 
	{
		return 1; /* Error */
	}
	
	return 0;

}

/*
*********************************************************************************************************
*	? ? ?: _ShowXBF
*	????: ??XBF??
*	?    ?:?
*	? ? ?: ?
*********************************************************************************************************
*/
static void _ShowXBF(void) 
{
	result = f_open(&file, "0:/songti.xbf", FA_OPEN_EXISTING | FA_READ | FA_OPEN_ALWAYS);
	if (result != FR_OK)
	{
		return;

	}
	
	//
	// Create XBF font
	//
	GUI_XBF_CreateFont(&XBF_Font,       // Pointer to GUI_FONT structure in RAM
					 &XBF_Data,         // Pointer to GUI_XBF_DATA structure in RAM
					 GUI_XBF_TYPE_PROP,//GUI_XBF_TYPE_PROP_EXT, 		// Font type to be created
					 _cbGetData,        // Pointer to callback function
					 &file);        // Pointer to be passed to GetData function
}

#else
//将XBF字库文件烧写在外部Flash空间内（脱离文件系统空间），实测显示速度快
/*
*********************************************************************************************************
*
*       _cbGetData
*
* Function description
*   Callback function for getting font data
*
* Parameters:
*   Off      - Position of XBF file to be read
*   NumBytes - Number of requested bytes
*   pVoid    - Application defined pointer
*   pBuffer  - Pointer to buffer to be filled by the function
*
* Return value:
*   0 on success, 1 on error
*********************************************************************************************************
*/
static int _cbGetData(U32 Offset, U16 NumBytes, void * pVoid, void * pBuffer)
{
	SPI_FLASH_BufferRead(pBuffer,60*4096+Offset,NumBytes);
	return 0;
}

static void _ShowXBF(void) 
{
	//
	// Create XBF font
	//
	GUI_XBF_CreateFont(&XBF_Font,       // Pointer to GUI_FONT structure in RAM
					   &XBF_Data,         // Pointer to GUI_XBF_DATA structure in RAM
					   GUI_XBF_TYPE_PROP,//GUI_XBF_TYPE_PROP_EXT, 		// Font type to be created
					   _cbGetData,        // Pointer to callback function
					   0);        // Pointer to be passed to GetData function
}
#endif
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  int NCode;
  int Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case GUI_ID_BUTTON0: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_SCROLLBAR0: // Notifications sent by 'Scrollbar'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_SLIDER0: // Notifications sent by 'Slider'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
	case WM_PAINT:
		GUI_DrawGradientV(0, 0, 240-1, 320-1, 0x0000FF, 0x00FFFF);
		GUI_SetColor(GUI_BLUE);
		GUI_SetFont(&XBF_Font);
		GUI_SetTextMode(GUI_TM_TRANS);	
		//为保证正确显示中文，必要条件（都是必须做的）
		//1.XBF字库文件必须已经烧写至外部Flash空间上
		//即已经正确运行：3.FATFS0.10_flash_write_HZLIB
		//2.本文件（TouchDemo.c）必须保存为UTF-8编码
		GUI_DispStringHCenterAt("XBF格式中文显示",110,10);
		GUI_DispStringAt("CPU使用率；",10,40);				
	break;
	case WM_TIMER://处理时间显示的信息，每秒钟修改一次时间
		{
			char cpu[6]={0};
			sprintf((char *)cpu,"%d",OSStatTaskCPUUsage);
			cpu[5]='\0';
			TEXT_SetText(WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0),cpu);
			WM_RestartTimer(pMsg->Data.v, 100);		
		}
		break;
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}
/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateTouch
*/
void CreateTouch(void) 
{
	WM_HWIN hWin;
	_ShowXBF();
	GUI_UC_SetEncodeUTF8();
    GUI_SetDefaultFont(&XBF_Font);
	hWin=GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
	WM_CreateTimer(hWin, 0, 1000, 0);
	GUI_Delay(10);
	LCD_BK_EN;//开液晶屏背光
	while(1)
	{
		GUI_Delay(10);
	}
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
