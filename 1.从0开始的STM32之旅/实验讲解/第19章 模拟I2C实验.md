# 第十九章 模拟I2C

## 1. 硬件设计

我们使用GPIO来模拟I2C，无其他硬件资源

## 2. 软件设计

- I2C的GPIO宏定义配置

```c
#define EEPROM_I2C_WR    0        // 写控制bit
#define EEPROM_I2C_RD    1        // 读控制bit

#define EEPROM_GPIO_PORT_I2C    GPIOB                  // 模拟I2C使用的端口
#define EEPROM_RCC_I2C_PORT     RCC_APB2Periph_GPIOB;  // 端口时钟
#define EEPROM_I2C_SCL_PIN      GPIO_Pin_6             // 连接到SCL时钟线的GPIO
#define EEPROM_I2C_SDA_PIN      GPIO_Pin_7             // 连接到SDA数据线的GPIO

// 定义读写SCL和SDA的宏，已增加代码的可移植性和可阅读性
#if 1    // 条件编译： 1 选择GPIO的库函数实现IO读写
    #define EEPROM_I2C_SCL_1()  GPIO_SetBits(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SCL_PIN)       // SCL = 1 
    #define EEPROM_I2C_SCL_0()  GPIO_ResetBits(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SCL_PIN)     // SCL = 0 

    #define EEPROM_I2C_SDA_1()  GPIO_SetBits(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SDA_PIN)       // SDA = 1 
    #define EEPROM_I2C_SDA_0()  GPIO_ResetBits(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SDA_PIN)     // SDA = 0 

    #define EEPROM_I2C_SDA_READ()  GPIO_ReadInputDataBit(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SDA_PIN)  // 读SDA口线状态
#else    // 这个分支选择直接寄存器操作实现IO读写
    /*　注意：如下写法，在IAR最高级别优化时，会被编译器错误优化 */
    #define EEPROM_I2C_SCL_1()  EEPROM_GPIO_PORT_I2C->BSRR = EEPROM_I2C_SCL_PIN               // SCL = 1 
    #define EEPROM_I2C_SCL_0()  EEPROM_GPIO_PORT_I2C->BRR = EEPROM_I2C_SCL_PIN                // SCL = 0 

    #define EEPROM_I2C_SDA_1()  EEPROM_GPIO_PORT_I2C->BSRR = EEPROM_I2C_SDA_PIN               // SDA = 1 
    #define EEPROM_I2C_SDA_0()  EEPROM_GPIO_PORT_I2C->BRR = EEPROM_I2C_SDA_PIN                // SDA = 0 

    #define EEPROM_I2C_SDA_READ()  ((EEPROM_GPIO_PORT_I2C->IDR & EEPROM_I2C_SDA_PIN) != 0)    // 读SDA口线状态
#endif
```

这些宏定义用于控制 I2C 总线的 SCL 和 SDA 信号线。具体功能如下：

- `EEPROM_I2C_SCL_1()` 和 `EEPROM_I2C_SCL_0()`：分别将 SCL 线设置为高电平（1）或低电平（0）。
- `EEPROM_I2C_SDA_1()` 和 `EEPROM_I2C_SDA_0()`：分别将 SDA 线设置为高电平（1）或低电平（0）。
- `EEPROM_I2C_SDA_READ()`：读取 SDA 线的当前电平状态。

为什么这些宏定义能实现功能呢？主要是靠三个库函数：

1. `GPIO_SetBits(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)`

- **目的**: 将指定的GPIO引脚设置为高电平（逻辑1）。

- **使用场景**: 用于将GPIO引脚设置为高电平。

- **参数**:
  
  - `GPIOx`: GPIO端口（例如，`GPIOA`、`GPIOB`等）。
  - `GPIO_Pin`: 需要设置的具体引脚（例如，`GPIO_Pin_0`、`GPIO_Pin_1`等）。

- **示例**:
  
  `GPIO_SetBits(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SCL_PIN);`
  
  这将SCL引脚设置为高电平。

2. `GPIO_ResetBits(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)`

- **目的**: 将指定的GPIO引脚设置为低电平（逻辑0）。

- **使用场景**: 用于将GPIO引脚设置为低电平。

- **参数**:
  
  - `GPIOx`: GPIO端口（例如，`GPIOA`、`GPIOB`等）。
  - `GPIO_Pin`: 需要重置的具体引脚（例如，`GPIO_Pin_0`、`GPIO_Pin_1`等）。

- **示例**:
  
  `GPIO_ResetBits(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SCL_PIN);`
  
  这将SCL引脚设置为低电平。

3. `GPIO_ReadInputDataBit(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)`

- **目的**: 读取指定GPIO引脚的当前电平。

- **使用场景**: 用于读取GPIO引脚的状态（高电平或低电平）。

- **参数**:
  
  - `GPIOx`: GPIO端口（例如，`GPIOA`、`GPIOB`等）。
  - `GPIO_Pin`: 需要读取的具体引脚（例如，`GPIO_Pin_0`、`GPIO_Pin_1`等）。

- **返回值**: `Bit_RESET`（逻辑0）或 `Bit_SET`（逻辑1）。

- **示例**:
  
  `uint8_t state = GPIO_ReadInputDataBit(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SDA_PIN);`
  
  这将读取SDA引脚的状态。

- 模拟I2C实现

```c
static void i2c_CfgGpio(void); // 初始化模拟I2C引脚

// 模拟I2C总线位延迟，最快400KHz
static void i2c_Delay(void)
{
    uint8_t i;
    /*　
         下面的时间是通过逻辑分析仪测试得到的。
        工作条件：CPU主频72MHz ，MDK编译环境，1级优化

        循环次数为10时，SCL频率 = 205KHz 
        循环次数为7时，SCL频率 = 347KHz， SCL高电平时间1.5us，SCL低电平时间2.87us 
         循环次数为5时，SCL频率 = 421KHz， SCL高电平时间1.25us，SCL低电平时间2.375us 
    */
    for (i = 0; i < 10; i++);
}

// CPU发起I2C总线启动信号
void i2c_Start(void)
{
    /* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
    EEPROM_I2C_SDA_1(); // 拉高SDA
    EEPROM_I2C_SCL_1(); // 拉高SCL
    i2c_Delay();
    EEPROM_I2C_SDA_0(); // 拉低SDA，产生启动信号
    i2c_Delay();
    EEPROM_I2C_SCL_0(); // 拉低SCL，产生一个时钟
    i2c_Delay();
}

// CPU发起I2C总线停止信号
void i2c_Stop(void)
{
    // 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号
    EEPROM_I2C_SDA_0(); // 拉低SDA
    EEPROM_I2C_SCL_1(); // 拉高SCL
    i2c_Delay();
    EEPROM_I2C_SDA_1(); // 拉高SDA，产生停止信号
}

// CPU向I2C总线设备发送8bit数据
void i2c_SendByte(uint8_t _ucByte) // 函数参数：要发送的8bit数据
{
    uint8_t i;

    /* 先发送字节的高位bit7 */
    for (i = 0; i < 8; i++)
    {        
        if (_ucByte & 0x80)
        {
            EEPROM_I2C_SDA_1(); // 发送高电平
        }
        else
        {
            EEPROM_I2C_SDA_0(); // 发送低电平
        }
        i2c_Delay();
        EEPROM_I2C_SCL_1(); // 拉高SCL
        i2c_Delay();    
        EEPROM_I2C_SCL_0(); // 拉低SCL，产生一个时钟
        if (i == 7)
        {
             EEPROM_I2C_SDA_1(); // 释放总线
        }
        _ucByte <<= 1;    // 左移一个bit
        i2c_Delay();
    }
}

// CPU从I2C总线设备读取8bit数据
uint8_t i2c_ReadByte(void)
{
    uint8_t i; // 要读取的bit位数
    uint8_t value; // 读取到的8bit数据

    // 读到第1个bit为数据的bit7 
    value = 0;
    for(i = 0; i < 8; i++)
    {
        value <<= 1;
        EEPROM_I2C_SCL_1();
        i2c_Delay();
        if (EEPROM_I2C_SDA_READ())
        {
            value++;
        }
        EEPROM_I2C_SCL_0();
        i2c_Delay();
    }
    return value;
}

// CPU产生一个时钟，并读取器件的ACK应答信号
uint8_t i2c_WaitAck(void)
{
    uint8_t re;

    EEPROM_I2C_SDA_1();    // CPU释放SDA总线
    i2c_Delay();
    EEPROM_I2C_SCL_1();    /* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
    i2c_Delay();
    if (EEPROM_I2C_SDA_READ()) // CPU读取SDA口线状态
    {
        re = 1; // 返回正常
    }
    else
    {
        re = 0; // 返回异常
    }
    EEPROM_I2C_SCL_0(); // 拉低SCL，产生一个时钟
    i2c_Delay();
    return re; // 返回ACK应答结果
}

// CPU产生一个ACK信号
void i2c_Ack(void)
{
    EEPROM_I2C_SDA_0();    // CPU驱动SDA = 0
    i2c_Delay();
    EEPROM_I2C_SCL_1();    // CPU产生1个时钟
    i2c_Delay();
    EEPROM_I2C_SCL_0();
    i2c_Delay();
    EEPROM_I2C_SDA_1();    // CPU释放SDA总线 
}

// CPU产生1个NACK信号
void i2c_NAck(void)
{
    EEPROM_I2C_SDA_1();    /* CPU驱动SDA = 1 */
    i2c_Delay();
    EEPROM_I2C_SCL_1();    /* CPU产生1个时钟 */
    i2c_Delay();
    EEPROM_I2C_SCL_0();
    i2c_Delay();    
}

// 配置I2C总线的GPIO，采用模拟IO的方式实现
static void i2c_CfgGpio(void)
{
    // 1.开头第一步，先定义一个结构体
    GPIO_InitTypeDef GPIO_InitStructure;

    // 2.使能GPIO时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

    // 3.配置GPIO引脚
    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SCL_PIN | EEPROM_I2C_SDA_PIN;

    // 4.设置GPIO为开漏输出模式，速度50MHz
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;  

    // 5.初始化GPIO
    GPIO_Init(EEPROM_GPIO_PORT_I2C, &GPIO_InitStructure);

    // 6.给一个停止信号，目的是恢复到初始状态
    i2c_Stop();
}

// 检测I2C总线设备，CPU向发送设备地址，然后读取设备应答来判断该设备是否存在
uint8_t i2c_CheckDevice(uint8_t _Address) // 函数参数：要检测的设备地址
{
    uint8_t ucAck; // 设备应答结果

    i2c_CfgGpio(); // GPIO初始化
    i2c_Start();   // 发送启动信号

    // 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 
    i2c_SendByte(_Address | EEPROM_I2C_WR);

    ucAck = i2c_WaitAck(); // 检测设备应答

    i2c_Stop(); // 传输完成，产生停止信号

    return ucAck; // 返回设备应答结果
}
```

写入EEPROM还是用的上一章的，无区别

- 主函数

```c
#include "stm32f10x.h"
#include "./usart/bsp_usart.h"
#include "./led/bsp_led.h" 
#include "./i2c/bsp_i2c_ee.h"

int main(void)
{

    LED_GPIO_Config();  
    LED_BLUE;
    USART_Config();

    printf("eeprom 读写测试实验 \r\n");        

    if(ee_Test() == 1)
      {
        LED_GREEN; 
    }
    else
    {
        LED_RED;
    }
    while(1);
}
```

## 3. 小结

模拟I2C就是模拟I2C的通讯过程，我们手动进行SDA、SCL拉高拉低，下面我们可以简单的进行复盘一下基本的I2C模拟：

### 1. 初始化GPIO

确保GPIO引脚被配置为推挽输出模式（SCL和SDA）和上拉模式（如果需要）。

### 2. 产生起始条件

将SDA从高电平拉到低电平时，SCL必须保持高电平。

```c
void I2C_Start(void) {
    GPIO_SetBits(GPIOx, SDA_PIN); // 确保SDA高电平
    GPIO_SetBits(GPIOx, SCL_PIN); // 确保SCL高电平
    Delay(); // 确保稳定性
    GPIO_ResetBits(GPIOx, SDA_PIN); // 将SDA拉低
    Delay();
    GPIO_ResetBits(GPIOx, SCL_PIN); // 将SCL拉低
}
```

### 3. 产生停止条件

将SDA从低电平拉到高电平时，SCL必须保持高电平。

```c
void I2C_Stop(void) {
    GPIO_ResetBits(GPIOx, SDA_PIN); // 确保SDA低电平
    GPIO_SetBits(GPIOx, SCL_PIN);   // 确保SCL高电平
    Delay(); // 确保稳定性
    GPIO_SetBits(GPIOx, SDA_PIN);   // 将SDA拉高
    Delay();
}
```

### 4. 写入位数据

将数据位写到SDA线，SCL线拉高以确认数据位。

```c
void I2C_WriteBit(uint8_t bit) {
    if (bit) {
        GPIO_SetBits(GPIOx, SDA_PIN); // 写入高电平
    } else {
        GPIO_ResetBits(GPIOx, SDA_PIN); // 写入低电平
    }
    GPIO_SetBits(GPIOx, SCL_PIN);   // 拉高SCL以读取数据
    Delay();
    GPIO_ResetBits(GPIOx, SCL_PIN); // 拉低SCL以准备下一位
}
```

### 5. 读取位数据

将SDA线配置为输入，并在SCL线拉高时读取数据。

```c
uint8_t I2C_ReadBit(void) {
    GPIO_SetBits(GPIOx, SCL_PIN);   // 拉高SCL以读取数据
    Delay();
    uint8_t bit = GPIO_ReadInputDataBit(GPIOx, SDA_PIN); // 读取SDA线的值
    GPIO_ResetBits(GPIOx, SCL_PIN); // 拉低SCL以准备下一位
    return bit;
}
```

### 6. 写入字节

写入一个字节，通过逐位调用 `I2C_WriteBit` 函数。

```c
void I2C_WriteByte(uint8_t byte) {
    for (int i = 0; i < 8; i++) {
        I2C_WriteBit((byte & 0x80) >> 7); // 写入最高位
        byte <<= 1; // 移动到下一位
    }
}
```

### 7. 读取字节

读取一个字节，通过逐位调用 `I2C_ReadBit` 函数。

```c
uint8_t I2C_ReadByte(void) {
    uint8_t byte = 0;
    for (int i = 0; i < 8; i++) {
        byte <<= 1; // 移动到下一位
        byte |= I2C_ReadBit(); // 读取当前位
    }
    return byte;
}
```

---

2024.9.4 第一次修订，后期不再维护
