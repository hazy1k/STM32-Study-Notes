# 第二十五章 基本定时器定时实验

## 1. 硬件设计

本实验利用基本定时器 TIM6/7 定时 1s，1s 时间到 LED 翻转一次。基本定时器是单片机内部的资源， 没有外部 IO，不需要接外部电路，现只需要一个 LED 即可。

## 2. 软件设计

### 2.1 编程目标

1. 开定时器时钟 TIMx_CLK, x[6,7]；

2. 初始化时基初始化结构体；

3. 使能 TIMx, x[6,7] update 中断；

4. 打开定时器；

5. 编写中断服务程序

通用定时器和高级定时器的定时编程要点跟基本定时器差不多，只是还要再选择下计数器的计数模式， 是向上还是向下。因为基本定时器只能向上计数，且没有配置计数模式的寄存器，默认是向上。

### 2.2 代码分析

- 基本定时器宏定义

```c
#define BASIC_TIM6 // 如果使用TIM7，注释掉这个宏即可

#ifdef  BASIC_TIM6 // 使用基本定时器TIM6
#define            BASIC_TIM                   TIM6                   // 选择使用的定时器--TIM6
#define            BASIC_TIM_APBxClock_FUN     RCC_APB1PeriphClockCmd // 使能定时器时钟--APB1
#define            BASIC_TIM_CLK               RCC_APB1Periph_TIM6    // 定时器时钟--TIM6
#define            BASIC_TIM_Period            1000-1                 // 定时器周期--1000-1
#define            BASIC_TIM_Prescaler         71                     // 定时器分频器--71
#define            BASIC_TIM_IRQ               TIM6_IRQn              // 定时器中断向量号--TIM6_IRQn
#define            BASIC_TIM_IRQHandler        TIM6_IRQHandler        // 定时器中断服务程序--TIM6_IRQHandler

#else  // 使用基本定时器TIM7
#define            BASIC_TIM                   TIM7
#define            BASIC_TIM_APBxClock_FUN     RCC_APB1PeriphClockCmd
#define            BASIC_TIM_CLK               RCC_APB1Periph_TIM7
#define            BASIC_TIM_Period            1000-1
#define            BASIC_TIM_Prescaler         71
#define            BASIC_TIM_IRQ               TIM7_IRQn
#define            BASIC_TIM_IRQHandler        TIM7_IRQHandler

#endif
```

基本定时器有 TIM6 和 TIM7，我们可以有选择的使用，为了提高代码的可移植性，我们把当需要修改定时器时需要修改的代码定义成宏， 默认使用的是定时器 6，如果想修改成定时器 7，只需要把宏 BASIC_TIM6 注释掉即可。

- 基本定时器配置

```c
// 基本定时器模式配置
static void BASIC_TIM_Mode_Config(void)
{
    // 1.定义结构体
    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
		
		// 2.开启定时器时钟,即内部时钟CK_INT=72M
    BASIC_TIM_APBxClock_FUN(BASIC_TIM_CLK, ENABLE);
	
		// 3.自动重装载寄存器的值，累计TIM_Period+1个频率后产生一个更新或者中断
    TIM_TimeBaseStructure.TIM_Period = BASIC_TIM_Period;	

	  // 4.时钟预分频数为
    TIM_TimeBaseStructure.TIM_Prescaler= BASIC_TIM_Prescaler;
	
		// 时钟分频因子 ，基本定时器没有，不用管
    //TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1;
		
		// 计数器计数模式，基本定时器只能向上计数，没有计数模式的设置
    //TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up; 
		
		// 重复计数器的值，基本定时器没有，不用管
		//TIM_TimeBaseStructure.TIM_RepetitionCounter=0;
	
	  // 5.初始化定时器
    TIM_TimeBaseInit(BASIC_TIM, &TIM_TimeBaseStructure);
		
		// 6.清除计数器中断标志位
    TIM_ClearFlag(BASIC_TIM, TIM_FLAG_Update);
	  
		// 7.开启计数器中断
    TIM_ITConfig(BASIC_TIM,TIM_IT_Update,ENABLE);
		
		// 8.使能计数器
    TIM_Cmd(BASIC_TIM, ENABLE);	
}
```

我们把定时器设置自动重装载寄存器 ARR 的值为 1000，设置时钟预分频器为 71， 则驱动计数器的时钟：CK_CNT = CK_INT / (71+1)=1M， 则计数器计数一次的时间等于：1/CK_CNT=1us，当计数器计数到 ARR 的值 1000时， 产生一次中断，则中断一次的时间为：1/CK_CNT*ARR=1ms。

在初始化定时器的时候，我们定义了一个结构体：TIM_TimeBaseInitTypeDef， TIM_TimeBaseInitTypeDef 结构体里面有 5 个成员， TIM6 和 TIM7 的寄存器里面只有TIM_Prescaler 和 TIM_Period，另外三个成员基本定时器是没有的， 所以使用TIM6 和TIM7 的时候只需初始化这两个成员即可， 另外三个成员是通用定时器和高级定时器才有，具体说明如下：

```c
typedef struct {
    TIM_Prescaler            // 都有
    TIM_CounterMode          // TIMx,x[6,7]没有，其他都有
    TIM_Period               // 都有
    TIM_ClockDivision        // TIMx,x[6,7]没有，其他都有
    TIM_RepetitionCounter    // TIMx,x[1,8,15,16,17]才有
} TIM_TimeBaseInitTypeDef;
```

其中 TIM15/16/17 只存在与互联型产品中，在 F1 大/中/小容量型号中没有。

- 定时器中断优先级配置

```c
// 中断优先级配置
void BASIC_TIM_NVIC_Config(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    // 设置中断组为0
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
    // 设置中断来源
    NVIC_InitStructure.NVIC_IRQChannel = BASIC_TIM_IRQ ;
    // 设置主优先级为 0
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    // 设置抢占优先级为3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}
```

我们设置中断分组为 0，主优先级为 0，抢占优先级为 3。

- 定时器中断服务程序

```c
void  BASIC_TIM_IRQHandler (void)
{
    if ( TIM_GetITStatus( BASIC_TIM, TIM_IT_Update) != RESET ) {
        time++;
        TIM_ClearITPendingBit(BASIC_TIM , TIM_FLAG_Update);
    }
}
```

定时器中断一次的时间是 1ms，我们定义一个全局变量 time，每当进一次中断的时候，让time 来记录进入中断的次数。 如果我们想实现一个 1s 的定时，我们只需要判断 time 是否等于 1000 即可，1000 个 1ms 就是 1s。 然后把 time 清0，重新计数，以此循环往复。在中断服务程序的最后，要把相应的中断标志位清除掉，切记。

- 主函数

```c
// 基本定时器TIMx,x[6,7]定时应用
#include "stm32f10x.h"
#include "bsp_led.h"
#include "bsp_TiMbase.h"

volatile uint32_t time = 0; // ms 计时变量 

int main(void)
{
	LED_GPIO_Config();	
	BASIC_TIM_Init();
	
  while(1)
  {
    if (time == 1000) // 1000 * 1 ms = 1s 时间到 
    {
      time = 0;
			LED1_TOGGLE; 
    }        
  }
}
```

主函数做一些必须的初始化，然后在一个死循环中不断的判断 time 的值，time的值在定时器中断改变， 每加一次表示定时器过了 1ms，当 time 等于 1000 时，1s时间到，LED1翻转一次，并把 time 清 0。
