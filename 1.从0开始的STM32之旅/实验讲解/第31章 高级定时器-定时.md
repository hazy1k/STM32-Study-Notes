# 第三十一章 高级定时器-定时

## 1. 硬件设计

次实验使用到了LED模块，可以参考之前的，再有高级定时器无需硬件设计啦

## 2. 软件设计

- 高级定时器相关参数宏定义

```c
#define ADVANCE_TIM1 // 如果使用TIM8，注释掉这个宏即可

#ifdef  ADVANCE_TIM1 // 使用高级定时器TIM1
// TIM1参数定义
#define ADVANCE_TIM                TIM1                   // 高级定时器TIM1
#define ADVANCE_TIM_APBxClock_FUN  RCC_APB2PeriphClockCmd // 高级定时器挂载APB2时钟
#define ADVANCE_TIM_CLK            RCC_APB2Periph_TIM1    // 高级定时器时钟源
#define ADVANCE_TIM_Period         (1000-1)               // 高级定时器周期
#define ADVANCE_TIM_Prescaler      71                     // 高级定时器分频系数
#define ADVANCE_TIM_IRQ            TIM1_UP_IRQn           // 高级定时器中断向量
#define ADVANCE_TIM_IRQHandler     TIM1_UP_IRQHandler     // 高级定时器中断服务函数

#else  // 使用高级定时器TIM8
#define ADVANCE_TIM                TIM8
#define ADVANCE_TIM_APBxClock_FUN  RCC_APB2PeriphClockCmd
#define ADVANCE_TIM_CLK            RCC_APB2Periph_TIM8
#define ADVANCE_TIM_Period         (1000-1)
#define ADVANCE_TIM_Prescaler      71
#define ADVANCE_TIM_IRQ            TIM8_UP_IRQn
#define ADVANCE_TIM_IRQHandler     TIM8_UP_IRQHandler

#endif
```

- 中断向量配置

```c
// 中断优先级配置
static void ADVANCE_TIM_NVIC_Config(void)
{
    NVIC_InitTypeDef NVIC_InitStructure; 
    // 设置中断组为0
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);        
    // 设置中断来源
    NVIC_InitStructure.NVIC_IRQChannel = ADVANCE_TIM_IRQ ;    
    // 设置主优先级为 0
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;     
    // 设置抢占优先级为3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;    
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; // 开启中断
    NVIC_Init(&NVIC_InitStructure); // 初始化NVIC
}
```

- 中断处理函数

```c
void  ADVANCE_TIM_IRQHandler (void)
{
    if(TIM_GetITStatus(ADVANCE_TIM, TIM_IT_Update) != RESET) 
    {    
        time++;
        TIM_ClearITPendingBit(ADVANCE_TIM , TIM_FLAG_Update);           
    }             
}
```

- 高级定时器模式配置

```c
// 高级定时器模式配置
static void ADVANCE_TIM_Mode_Config(void)
{
    // 1.定义一个定时器结构体
    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;        
    // 2.开启定时器时钟,即内部时钟 CK_INT=72M
    ADVANCE_TIM_APBxClock_FUN(ADVANCE_TIM_CLK, ENABLE);    
    // 3.自动重装载寄存器的值，累计 TIM_Period+1 个频率后产生一个更新或者中断
    TIM_TimeBaseStructure.TIM_Period = ADVANCE_TIM_Period;
    // 4.时钟预分频数
    TIM_TimeBaseStructure.TIM_Prescaler = ADVANCE_TIM_Prescaler;    
    // 5.时钟分频因子 ，没用到不用管
    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;        
    // 6.计数器计数模式，设置为向上计数
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;         
    // 7.重复计数器的值，没用到不用管
    TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;    
    // 8.初始化定时器
    TIM_TimeBaseInit(ADVANCE_TIM, &TIM_TimeBaseStructure);
    // 9.清除计数器中断标志位
    TIM_ClearFlag(ADVANCE_TIM, TIM_FLAG_Update);
    // 10.开启计数器中断
    TIM_ITConfig(ADVANCE_TIM,TIM_IT_Update, ENABLE);
    // 11.使能计数器
    TIM_Cmd(ADVANCE_TIM, ENABLE);
}
```

- 主函数

```c
// 高级定时器TIMx,x[1,8]定时应用
#include "stm32f10x.h"
#include "bsp_led.h"
#include "bsp_AdvanceTim.h" 

uint32_t time = 0; // ms 计时变量 

int main(void)
{ 
    LED_GPIO_Config();
    ADVANCE_TIM_Init();

  while(1)
  {
    if(time == 1000 ) // 1000 * 1 ms = 1s 时间到 
    {
      time = 0;
      // LED1 取反      
      LED1_TOGGLE; 
    }        
  }
}
```

## 3. 小结

这个与其他定时器无异，只是基本使用，无法体现高级定时器的功能，那我们再来回顾一下定时器基本配置的流程吧：

### **1. 定义定时器结构体**

```c
TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
```

- 这行代码定义了一个`TIM_TimeBaseInitTypeDef`类型的结构体`TIM_TimeBaseStructure`。这个结构体用于配置定时器的基本参数，如计数周期、预分频器等。

### **2. 开启定时器时钟**

```c
ADVANCE_TIM_APBxClock_FUN(ADVANCE_TIM_CLK, ENABLE);
```

- 通过调用`ADVANCE_TIM_APBxClock_FUN`函数启用与定时器相关的时钟。`ADVANCE_TIM_CLK`是要使能的时钟源（例如`RCC_APB2Periph_TIM1`），`ENABLE`表示开启时钟。
- 这一步骤是必须的，因为定时器在未使能其时钟之前无法正常工作。

### **3. 配置自动重装载寄存器**

```c
TIM_TimeBaseStructure.TIM_Period = ADVANCE_TIM_Period;
```

- `TIM_Period`设置了定时器的自动重装载寄存器的值。定时器会在计数到这个值后重新从零开始计数，从而触发一个更新事件或中断。

### **4. 配置时钟预分频数**

```c
TIM_TimeBaseStructure.TIM_Prescaler = ADVANCE_TIM_Prescaler;
```

- `TIM_Prescaler`设置了时钟的预分频值。定时器时钟频率通过将输入时钟除以`TIM_Prescaler`来降低。这决定了定时器的计数频率。

### **5. 时钟分频因子**

```c
TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
```

- `TIM_ClockDivision`指定了时钟的分频因子。在这里，它被设置为`TIM_CKD_DIV1`，表示没有额外的分频。这一项在很多情况下可以忽略，特别是当使用定时器的基本模式时。

### **6. 计数器计数模式**

```c
TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
```

### **7. 重复计数器的值**

```c
TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
```

- `TIM_RepetitionCounter`用于高级定时器的重载计数模式，但在此代码中设置为`0`，表示不使用该功能。

### **8. 初始化定时器**

```c
TIM_TimeBaseInit(ADVANCE_TIM, &TIM_TimeBaseStructure);
```

### **9. 清除计数器中断标志位**

```c
TIM_ClearFlag(ADVANCE_TIM, TIM_FLAG_Update);
```

- `TIM_ClearFlag`函数用于清除定时器的更新中断标志位。通常在中断处理程序中或在启用中断之前需要清除标志位，以防止错误的中断触发。

### **10. 开启计数器中断**

```c
TIM_ITConfig(ADVANCE_TIM, TIM_IT_Update, ENABLE);
```

- `TIM_ITConfig`函数用于配置定时器的中断。这里设置`TIM_IT_Update`中断为使能状态，以便定时器达到更新事件时产生中断。

### **11. 使能计数器**

```c
TIM_Cmd(ADVANCE_TIM, ENABLE);
```

- 最后，调用`TIM_Cmd`函数启用定时器。此时定时器开始工作，并根据设置的周期和预分频值产生定时器中断或事件。

---

2024.9.13 第一次修订，后期不再维护
