# 第二十八章 LCD-液晶显示中英文

## 1. 字符编码

由于计算机只能识别0和1，文字也只能以0和1的形式在计算机里存储，所以我们需要对文字进行编码才能让计算机处理， 编码的过程就是规定特定的01数字串来表示特定的文字，最简单的字符编码例子是ASCII码。

## 2. 什么是字模

有了编码，我们就能在计算机中处理、存储字符了，但是如果计算机处理完字符后直接以编码的形式输出，人类将难以识别。 来，在2秒内告诉我ASCII编码的“0x25”表示什么字符？不容易吧？要是觉得容易，再来告诉我GBK编码的“0xBCC6”表示什么字符。 因此计算机与人交互时，一般会把字符转化成人类习惯的表现形式进行输出，如显示、打印的时候。

但是如果仅有字符编码，计算机还不知道该如何表达该字符，因为字符实际上是一个个独特的图形， 计算机必须把字符编码转化成对应的字符图形人类才能正常识别，因此我们要给计算机提供字符的图形数据，这些数据就是字模， 多个字模数据组成的文件也被称为字库。计算机显示字符时，根据字符编码与字模数据的映射关系找到它相应的字模数据，液晶屏根据字模数据显示该字符。

### 2.1 字模的构成

已知字模是图形数据，而图形在计算机中是由一个个像素点组成的，所以字模实质是一个个像素点数据。 为方便处理，我们把字模定义成方块形的像素点阵，且每个像素点只有0和1这两种状态(可以理解为单色图像数据)。见图 [字模](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LCD_display.html#id14) ， 这是两个宽、高为16x16的像素点阵组成的两个汉字图形，其中的黑色像素点即为文字的笔迹。计算机要表示这样的图形， 只需使用16x16个二进制数据位，每个数据位记录一个像素点的状态，把黑色像素点以“1”表示，无色像素点以“0”表示即可。 这样的一个汉字图形，使用16x16/8=32个字节来就可以记录下来。

<img title="" src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LCDdis003.png" alt="" width="405">

16x16的“字”的字模数据以C语言数组的方式表示，在这样的字模中，以两个字节表示一行像素点，16行构成一个字模。

```c
/* 字 */
unsigned char code Bmp003[]=
{
/*------------------------------------------------------------
;  源文件 / 文字 : 字
;  宽×高（像素）: 16×16
;  字模格式/大小 : 单色点阵液晶字模，横向取模，字节正序/32字节
----------------------------------------------------------*/

0x02,0x00,0x01,0x00,0x3F,0xFC,0x20,0x04,0x40,0x08,0x1F,0xE0,0x00,0x40,0x00,0x80,
0xFF,0xFF,0x7F,0xFE,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x05,0x00,0x02,0x00,
};
```

### 2.2 字模显示原理

如果使用LCD的画点函数，按位来扫描这些字模数据，把为1的位以黑色来显示(也可以使用其它颜色)，为0的数据位以白色来显示， 即可把整个点阵还原出来，显示在液晶屏上。

为便于理解，我们编写了一个使用串口printf利用字模打印字符到串口上位机：

```c
/*"当"字符的字模16x16 */
unsigned char charater_matrix[] = {
    /*"当",0*/
    0x01,0x00,0x21,0x08,0x11,0x08,0x09,0x10,
    0x09,0x20,0x01,0x00,0x7F,0xF8,0x00,0x08,
    0x00,0x08,0x00,0x08,0x3F,0xF8,0x00,0x08,
    0x00,0x08,0x00,0x08,0x7F,0xF8,0x00,0x08,
};

/**
* @brief  使用串口在上位机打印字模
*         演示字模显示原理
* @retval 无
*/
void Printf_Charater(void)
{
    int i,j;
    unsigned char kk;

    /*i用作行计数*/
    for ( i=0; i<16; i++) {
        /*j用作一字节内数据的移位计数*/
        /*一行像素的第一个字节*/
        for (j=0; j<8; j++) {
            /*一个数据位一个数据位地处理*/
            kk = charater_matrix[2*i] << j ;  //左移J位
            if ( kk & 0x80) {
                printf("*"); //如果最高位为1，输出*号，表示笔迹
            } else {
                printf(" "); //如果最高位为0，输出空格，表示空白
            }
        }
        /*一行像素的第二个字节*/
        for (j=0; j<8; j++) {
            kk = charater_matrix[2*i+1] << j ;  //左移J位

            if ( kk & 0x80) {
                printf("*"); //如果最高位为1，输出*号，表示笔迹
            } else {
                printf(" "); //如果最高位为0，输出空格，表示空白
            }
        }
        printf("\n");    //输出完一行像素，换行
    }
    printf("\n\n");     //一个字输出完毕
}
```

### 2.3 如何制作字模

以上只是某几个字符的字模，为方便使用，我们需要制作所有常用字符的字模，如程序只需要英文显示， 那就需要制作包含ASCII码表 [ASCII码中的字符和数字](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LCD_display.html#id3) 中所有字符的字模， 如程序只需要使用一些常用汉字，我们可以选择制作GB2312编码里所有字符的字模，而且希望字模数据与字符编码有固定的映射关系， 以便在程序中使用字符编码作为索引，查找字模。在网上搜索可找到一些制作字模的软件工具，可满足这些需求。 在我们提供的《液晶显示中英文》的工程目录下提供了一个取模软件“PCtoLCD”，这里以它为例讲解如何制作字模，其它字模软件也是类似的。

1. 配置字模格式
- 选项“点阵格式”中的阴、阳码是指字模点阵中有笔迹像素位的状态是“1”还是“0”，像我们前文介绍的那种就是阴码，反过来就是阳码。本工程中使用阴码。

- 选项“取模方式”是指字模图形的扫描方向，修改这部分的设置后，选项框的右侧会有相应的说明及动画显示，这里我们依然按前文介绍的字模类型，把它配置成“逐行式”

- 选项“每行显示的数据”里我们把点阵和索引都配置成16，设置这个点阵的像素大小为16x16。

![](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LCDdis005.jpg)

2. 生成GB2312字模

配置完字模选项后，点击软件中的导入文本图标，会弹出一个“生成字库”的对话框， 点击右下角的生成国标汉字库按钮即可生成包含了GB2312编码里所有字符的字模文件。 在《液晶显示中英文》的工程目录下的《GB2312_H1616.FON》是我用这个取模软件生成的字模原文件，若不想自己制作字模，可直接使用该文件。

![](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LCDdis006.jpg)

## 2.4 字模寻址公式

使用字模软件制作的字模数据一般会按照编码格式排列。如我们利用以上软件生成的字模文件《GB2312_H2424.FON》中的数据， 是根据GB2312的区位码表的顺序存储的，它存储了区位码为0101-9494的字符，每个字模的大小为16x16/8=32字节。 其中第一个字符“空格”的区位码为0101，它是首个字符，所以文件的前32字节存储的是它的字模数据； 同理，32-64字节存储的则是0102字符“、”的字模数据。所以我们可以导出任意字符的寻址公式:

![屏幕截图 2024 09 11 183307](https://img.picgo.net/2024/09/11/-2024-09-11-1833077ea207ee9e8fe3ed.png)

其中Code<sub>H和Code<sub>L分别是GB2312编码的第一字节和第二字节；94是指一个区中有94个位(即94个字符)。 公式的实质是根据字符的GB2312编码，求出区位码，然后区位码乘以每个字符占据的字节数，求出地址偏移。

## 2.5 存储字模文件

上面生成的《GB2312_H1616.FON》文件的大小为256KB，比很多STM32芯片内部的所有FLASH空间都大，如果我们还是在程序中直接以C语言数组的方式存储字模数据， STM32芯片的程序空间会非常紧张，一般的做法是把字模数据存储到外部存储器，如SD卡或SPI-FLASH芯片，当需要显示某个字符时， 控制器根据字符的编码算好字模的存储地址，再从存储器中读取，而FLASH芯片在生产前就固化好字模内容，然后直接把FLASH芯片贴到电路板上，作为整个系统的一部分。
